// lib/restaurant-canvas/coordinate-utils.ts
import { RESTAURANT_CANVAS_CONFIG } from './canvas-config';
import type { CanvasPosition, GridCoordinate, LegacyTableData, RestaurantTable } from './types';

// ============================================================================
// COORDINATE CONVERSION UTILITIES
// ============================================================================

/**
 * Convert grid coordinates to pixel coordinates
 */
export const gridToPixel = (gridX: number, gridY: number): CanvasPosition => {
  return {
    x: RESTAURANT_CANVAS_CONFIG.GRID.centerX + gridX * RESTAURANT_CANVAS_CONFIG.GRID.cellSize,
    y: RESTAURANT_CANVAS_CONFIG.GRID.centerY + gridY * RESTAURANT_CANVAS_CONFIG.GRID.cellSize,
  };
};

/**
 * Convert pixel coordinates to grid coordinates
 */
export const pixelToGrid = (pixelX: number, pixelY: number): GridCoordinate => {
  return {
    gridX: Math.round((pixelX - RESTAURANT_CANVAS_CONFIG.GRID.centerX) / RESTAURANT_CANVAS_CONFIG.GRID.cellSize),
    gridY: Math.round((pixelY - RESTAURANT_CANVAS_CONFIG.GRID.centerY) / RESTAURANT_CANVAS_CONFIG.GRID.cellSize),
  };
};

/**
 * Snap pixel coordinates to grid
 */
export const snapToGrid = (pixelX: number, pixelY: number): CanvasPosition => {
  const gridCoord = pixelToGrid(pixelX, pixelY);
  return gridToPixel(gridCoord.gridX, gridCoord.gridY);
};

/**
 * Calculate distance between two points
 */
export const calculateDistance = (point1: CanvasPosition, point2: CanvasPosition): number => {
  const dx = point2.x - point1.x;
  const dy = point2.y - point1.y;
  return Math.sqrt(dx * dx + dy * dy);
};

/**
 * Calculate distance between two grid points
 */
export const calculateGridDistance = (point1: GridCoordinate, point2: GridCoordinate): number => {
  const dx = point2.gridX - point1.gridX;
  const dy = point2.gridY - point1.gridY;
  return Math.sqrt(dx * dx + dy * dy);
};

// ============================================================================
// LEGACY DATA CONVERSION
// ============================================================================

/**
 * Convert legacy table data (from your existing database) to canvas format
 */
export const convertLegacyTableToCanvas = (legacyTable: LegacyTableData): RestaurantTable => {
  // Convert pixel positions to grid coordinates
  const gridPosition = pixelToGrid(legacyTable.x_position, legacyTable.y_position);
  
  // Convert pixel size to grid size
  const gridSize = {
    width: Math.max(2, Math.round(legacyTable.width / RESTAURANT_CANVAS_CONFIG.GRID.cellSize)),
    height: Math.max(2, Math.round(legacyTable.height / RESTAURANT_CANVAS_CONFIG.GRID.cellSize)),
  };

  return {
    id: legacyTable.id,
    type: "table",
    subType: legacyTable.table_type,
    position: gridPosition,
    size: gridSize,
    rotation: 0, // Default rotation
    zIndex: 10, // Default z-index for tables
    seats: legacyTable.capacity,
    minSeats: legacyTable.min_capacity,
    maxSeats: legacyTable.max_capacity,
    status: "available", // Default status - will be updated by booking integration
    reservations: [], // Will be populated by booking integration
    chairs: [], // Will be generated by table factory
    
    // Preserve existing schema properties
    table_number: legacyTable.table_number,
    min_capacity: legacyTable.min_capacity,
    max_capacity: legacyTable.max_capacity,
    is_active: legacyTable.is_active,
    features: legacyTable.features,
    is_combinable: legacyTable.is_combinable,
    combinable_with: legacyTable.combinable_with,
    priority_score: legacyTable.priority_score,
    shape: legacyTable.shape,
    
    // Canvas-specific computed properties
    pixelPosition: gridToPixel(gridPosition.gridX, gridPosition.gridY),
    
    metadata: {
      created: legacyTable.created_at,
      lastModified: legacyTable.created_at,
      createdBy: "legacy-import",
    },
  };
};

/**
 * Convert canvas table back to legacy format for database updates
 */
export const convertCanvasTableToLegacy = (canvasTable: RestaurantTable): Partial<LegacyTableData> => {
  const pixelPosition = gridToPixel(canvasTable.position.gridX, canvasTable.position.gridY);
  const pixelSize = {
    width: canvasTable.size.width * RESTAURANT_CANVAS_CONFIG.GRID.cellSize,
    height: canvasTable.size.height * RESTAURANT_CANVAS_CONFIG.GRID.cellSize,
  };

  return {
    id: canvasTable.id,
    table_number: canvasTable.table_number,
    table_type: canvasTable.subType,
    capacity: canvasTable.seats,
    x_position: pixelPosition.x,
    y_position: pixelPosition.y,
    shape: canvasTable.shape,
    width: pixelSize.width,
    height: pixelSize.height,
    is_active: canvasTable.is_active,
    features: canvasTable.features,
    min_capacity: canvasTable.min_capacity,
    max_capacity: canvasTable.max_capacity,
    is_combinable: canvasTable.is_combinable,
    combinable_with: canvasTable.combinable_with,
    priority_score: canvasTable.priority_score,
  };
};

// ============================================================================
// VIEWPORT UTILITIES
// ============================================================================

/**
 * Calculate viewport bounds in grid coordinates
 */
export const calculateViewportBounds = (
  transform: { position: CanvasPosition; zoom: number },
  containerSize: { width: number; height: number }
) => {
  const scaledWidth = containerSize.width / transform.zoom;
  const scaledHeight = containerSize.height / transform.zoom;
  
  const centerX = -transform.position.x / transform.zoom;
  const centerY = -transform.position.y / transform.zoom;
  
  return {
    left: centerX - scaledWidth / 2,
    top: centerY - scaledHeight / 2,
    right: centerX + scaledWidth / 2,
    bottom: centerY + scaledHeight / 2,
  };
};

/**
 * Check if a table is visible in the current viewport
 */
export const isTableInViewport = (
  table: RestaurantTable,
  viewportBounds: { left: number; top: number; right: number; bottom: number }
): boolean => {
  const tablePixelPos = gridToPixel(table.position.gridX, table.position.gridY);
  const tablePixelSize = {
    width: table.size.width * RESTAURANT_CANVAS_CONFIG.GRID.cellSize,
    height: table.size.height * RESTAURANT_CANVAS_CONFIG.GRID.cellSize,
  };
  
  const tableBounds = {
    left: tablePixelPos.x - tablePixelSize.width / 2,
    top: tablePixelPos.y - tablePixelSize.height / 2,
    right: tablePixelPos.x + tablePixelSize.width / 2,
    bottom: tablePixelPos.y + tablePixelSize.height / 2,
  };
  
  return !(
    tableBounds.right < viewportBounds.left ||
    tableBounds.left > viewportBounds.right ||
    tableBounds.bottom < viewportBounds.top ||
    tableBounds.top > viewportBounds.bottom
  );
};

// ============================================================================
// COLLISION DETECTION
// ============================================================================

/**
 * Check if two tables overlap
 */
export const tablesOverlap = (table1: RestaurantTable, table2: RestaurantTable): boolean => {
  const t1Bounds = {
    left: table1.position.gridX - table1.size.width / 2,
    right: table1.position.gridX + table1.size.width / 2,
    top: table1.position.gridY - table1.size.height / 2,
    bottom: table1.position.gridY + table1.size.height / 2,
  };

  const t2Bounds = {
    left: table2.position.gridX - table2.size.width / 2,
    right: table2.position.gridX + table2.size.width / 2,
    top: table2.position.gridY - table2.size.height / 2,
    bottom: table2.position.gridY + table2.size.height / 2,
  };

  return !(
    t1Bounds.right <= t2Bounds.left ||
    t1Bounds.left >= t2Bounds.right ||
    t1Bounds.bottom <= t2Bounds.top ||
    t1Bounds.top >= t2Bounds.bottom
  );
};

/**
 * Find all tables that would overlap with a table at a given position
 */
export const findOverlappingTables = (
  targetTable: RestaurantTable,
  position: GridCoordinate,
  allTables: RestaurantTable[]
): RestaurantTable[] => {
  const testTable = {
    ...targetTable,
    position,
  };

  return allTables.filter(table => 
    table.id !== targetTable.id && tablesOverlap(testTable, table)
  );
};

// ============================================================================
// TRANSFORM UTILITIES
// ============================================================================

/**
 * Build CSS transform string for canvas positioning
 */
export const buildTransformString = (
  position: CanvasPosition,
  zoom: number,
  rotation: number = 0
): string => {
  return `translate(${position.x}px, ${position.y}px) scale(${zoom}) rotate(${rotation}deg)`;
};

/**
 * Calculate zoom level to fit all tables in viewport
 */
export const calculateFitZoom = (
  tables: RestaurantTable[],
  containerSize: { width: number; height: number }
): number => {
  if (tables.length === 0) return 1;

  // Find bounds of all tables
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  tables.forEach(table => {
    const pixelPos = gridToPixel(table.position.gridX, table.position.gridY);
    const halfWidth = (table.size.width * RESTAURANT_CANVAS_CONFIG.GRID.cellSize) / 2;
    const halfHeight = (table.size.height * RESTAURANT_CANVAS_CONFIG.GRID.cellSize) / 2;

    minX = Math.min(minX, pixelPos.x - halfWidth);
    maxX = Math.max(maxX, pixelPos.x + halfWidth);
    minY = Math.min(minY, pixelPos.y - halfHeight);
    maxY = Math.max(maxY, pixelPos.y + halfHeight);
  });

  const contentWidth = maxX - minX;
  const contentHeight = maxY - minY;

  // Add 20% padding
  const paddingFactor = 0.8;
  const zoomX = (containerSize.width * paddingFactor) / contentWidth;
  const zoomY = (containerSize.height * paddingFactor) / contentHeight;

  return Math.min(
    zoomX, 
    zoomY, 
    RESTAURANT_CANVAS_CONFIG.ZOOM.max
  );
};

/**
 * Calculate center position to fit all tables
 */
export const calculateFitCenter = (tables: RestaurantTable[]): CanvasPosition => {
  if (tables.length === 0) return { x: 0, y: 0 };

  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  tables.forEach(table => {
    const pixelPos = gridToPixel(table.position.gridX, table.position.gridY);
    minX = Math.min(minX, pixelPos.x);
    maxX = Math.max(maxX, pixelPos.x);
    minY = Math.min(minY, pixelPos.y);
    maxY = Math.max(maxY, pixelPos.y);
  });

  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;

  // Return the offset needed to center this content
  return {
    x: RESTAURANT_CANVAS_CONFIG.GRID.centerX - centerX,
    y: RESTAURANT_CANVAS_CONFIG.GRID.centerY - centerY,
  };
};
